    public unsafe partial class %CLASS_NAME% : SafeHandleZeroOrMinusOneIsInvalid
    {
        #region Handle
        /// <summary>
        /// Pointer to the underlying native object
        /// </summary>
        public IntPtr Handle => DangerousGetHandle();

        /// <summary>
        /// Create %CLASS_NAME% from a native pointer
        /// ownsHandle=false means GC won't delete the underlying native object if this C# wrapper goes out of scope
        /// </summary>
        public %CLASS_NAME%(IntPtr handle, bool ownsHandle) : base(ownsHandle) => SetHandle(handle);
        #endregion

        #region API
%API%
        #endregion

        #region DllImports
%DLLIMPORTS%
        #endregion

        #region ReleaseHandle
        protected override bool ReleaseHandle()
        {
            %CCLASS_NAME%__delete(Handle);
            return true;
        }

        [DllImport(%NATIVE_LIBRARY_PATH%, CallingConvention = CallingConvention.Cdecl)]
        private static extern void %CCLASS_NAME%__delete(IntPtr target);
        #endregion
    }

